# main.py

import os
import threading
import signal
import sys
from dotenv import load_dotenv, find_dotenv

from projectx_api import ProjectXAPI
from data_handler import DataHandler
from strategy import TradingStrategy
from config.timeframes import K, B, E
from typing import Dict
import threading
import time

load_dotenv(find_dotenv(), override=True)

def start_periodic_summary(strategies: Dict[str, TradingStrategy], interval: int = 30):
    def _report():
        for strat in strategies.values():
            strat.controller.print_summary()
        t = threading.Timer(interval, _report)
        t.daemon = True
        t.start()

    t0 = threading.Timer(interval, _report)
    t0.daemon = True
    t0.start()

def shutdown(signum, frame):
    print("\nStop signal received, shutting down …")
    try:
        handler.stop()
    except Exception:
        pass
    sys.exit(0)

def resolve_contract_id_by_name(api: ProjectXAPI, symbol_name: str):
    contracts = api.search_contracts(search_text=symbol_name)
    if not contracts:
        raise ValueError(f"Kein Contract mit Bezug zu '{symbol_name}' gefunden.")

    for c in contracts:
        if symbol_name.lower() in (c.get("name", "").lower(), c.get("description", "").lower(), c.get("id", "").lower()):
            return c

    print(f"⚠️ Kein exakter Treffer für '{symbol_name}', Rückfall auf ersten Eintrag.")
    return contracts[0]


if __name__ == '__main__':
    signal.signal(signal.SIGINT, shutdown)
    signal.signal(signal.SIGTERM, shutdown)

    try:
        API_USER = os.environ['API_USER']
        API_KEY  = os.environ['API_KEY']
    except KeyError as e:
        raise RuntimeError(f"Umgebungsvariable {e.args[0]} fehlt")

    api = ProjectXAPI(username=API_USER, api_key=API_KEY)
    
    
    #Print für NQ
    print("→ Verfügbare MNQ-Kontrakte:")
    contracts = api.search_contracts(search_text="MNQ")
    for c in contracts:
        print(c.get("id"), c.get("name"), c.get("description"))

    #Print für GC
    print("→ Verfügbare GC-Kontrakte:")
    contracts = api.search_contracts(search_text="GC")
    for c in contracts:
        print(c.get("id"), c.get("name"), c.get("description"))
    
    #Print für YM
    print("→ Verfügbare GC-Kontrakte:")
    contracts = api.search_contracts(search_text="YM")
    for c in contracts:
        print(c.get("id"), c.get("name"), c.get("description"))




    accounts = api.get_active_accounts()
    if not accounts:
        raise RuntimeError("Kein aktives Konto gefunden")

    acct = accounts[0]
    account_id = acct['id']
    INITIAL_BALANCE = acct.get("balance", 0.0)
    if account_id is None:
        raise RuntimeError("API: Konto‐Informationen konnten nicht abgerufen werden")

    SYMBOL_NAMES = ["MNQM5", "MGCQ5", "MYMM5"]
    SYMBOLS = []
    symbol_params = {}

    # DataHandler EINMAL erzeugen
    handler = DataHandler(api, account_id)
    threading.Thread(target=handler.run, daemon=True).start()

    for symbol_name in SYMBOL_NAMES:
        contract = api.get_contract_by_name(symbol_name)
        contract_id = contract["id"]
        SYMBOLS.append(contract_id)

        tick_size = contract.get("tickSize")
        if tick_size is None or tick_size <= 0:
            raise RuntimeError(f"Ungültige Tick-Größe für {symbol_name}")

        try:
            quote_symbol = contract["name"]  # Symbol für Quote-Request
            print(f"→ Versuche Quote für Symbol '{quote_symbol}' (Contract-ID: {contract_id}) zu laden")
            quote = api.get_quote(contract_id=contract_id)
            bid = quote.get("bid")
            ask = quote.get("ask")
            if bid is None or ask is None:
                raise ValueError("Bid oder Ask fehlt")
            spread = ask - bid
        except Exception as e:
            print(f"⚠️ Quote für {quote_symbol} konnte nicht geladen werden: {e}")
            spread = 0

        symbol_params[contract_id] = {
            'tick_size': tick_size,
            'spread': spread
        }





    # Strategien initialisieren
    strategies: Dict[str, TradingStrategy] = {}
    for sym in SYMBOLS:
        params = symbol_params[sym]
        strat = TradingStrategy(
            symbol=sym,
            api=api,
            account_id=account_id,
            data_handler=handler,
            account_balance=INITIAL_BALANCE,
            tick_size=params['tick_size'],
            spread=params['spread']
        )
        strat.controller.initialize()
        strat.start()
        strategies[sym] = strat

    # Periodische Summary
    start_periodic_summary(strategies, interval=15)

    # Start Event-Loop
    t = threading.Thread(target=handler.run, daemon=True)
    t.start()
    
    try:
        while True:
            time.sleep(60)
    except KeyboardInterrupt:
        print("Shutdown durch Benutzer")
