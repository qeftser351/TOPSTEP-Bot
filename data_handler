import time
from datetime import datetime
import math
from typing import Dict, List, Callable, Optional
from types import SimpleNamespace
from core.types import Candle
from config.timeframes import get_history_limit, aggregate_candles, TIMEFRAMES
get_history_limit = lambda tf: int(300 * (tf / 15))
from core.phase_manager import PhaseStateMachine
import pytz
from projectx_api import ProjectXAPI
from datetime import datetime, timedelta
import pandas as pd
from config.timeframes import aggregate_candles
from requests.exceptions import HTTPError




class DataHandler:
    # Mapping von MT5-Konstanten auf interne Labels (nur als Referenz, wird hier nicht verwendet)
    TIMEFRAME_MAP: Dict[int, str] = {
        # mt5.TIMEFRAME_M1:  '1m',
        # mt5.TIMEFRAME_M15: '15m',
        # mt5.TIMEFRAME_H1:  '1h',
    }

    def __init__(self, api: ProjectXAPI, account_id: int):
        self.api = api
        self.account_id = account_id
        self.histories: Dict[str, Dict[int, List[Candle]]] = {}
        self.subscribers: Dict[str, Dict[int, List[Callable]]] = {}
        self.phase_machine = PhaseStateMachine()
        self._running = False
        self.open_ticket: Optional[int] = None
        self._pending_to_position: Dict[str, Dict[int, int]] = {}
        self.last_history_ts: Dict[str, Dict[int, Optional[datetime]]] = {}
        self.contract_details_cache: Dict[str, dict] = {}
        self.contract_name_cache: Dict[str, str] = {}
        self.ws_client = None


    def fetch_history(self, contract_id: str, timeframe: int, limit: int) -> List[Candle]:
        """
        Holt historische Kerzen im kleinsten TF (15s) und aggregiert auf den gewünschten timeframe (in Sekunden).
        """
        # 1) Zeitfenster berechnen
        end_time = datetime.utcnow()
        start_time = end_time - timedelta(seconds=timeframe * limit)

        # 2) Rohdaten vom Server (15s-Bars) holen
        raw = self.api.get_candles(
            contract_id=contract_id,
            unit=1,                 # 1 = Sekunden
            unit_number=15,         # 15s-Bars
            limit=limit * (timeframe // 15),
            live=False,
            start_time=start_time,
            end_time=end_time,
            include_partial_bar=False
        )

        # 3) Spalten umbenennen für Aggregation
        df = pd.DataFrame(raw)
        df.rename(columns={
            "t": "timestamp",
            "o": "open",
            "h": "high",
            "l": "low",
            "c": "close",
            "v": "volume"
        }, inplace=True)

        # 4) Auf Ziel-Timeframe aggregieren
        agg = aggregate_candles(df.to_dict(orient="records"), timeframe)

        # 5) In dein Candle-Objekt konvertieren
        candles: List[Candle] = []
        for bar in agg:
            ts_ms = bar["timestamp"]
            ts = datetime.utcfromtimestamp(ts_ms / 1000)
            candles.append(Candle(
                timestamp=ts,
                open=bar["open"],
                high=bar["high"],
                low=bar["low"],
                close=bar["close"],
                volume=bar["volume"]
            ))

        # 6) Optional: Cache + Rückgabe
        self.histories.setdefault(contract_id, {})[timeframe] = candles.copy()
        self.last_history_ts.setdefault(contract_id, {})[timeframe] = candles[-1].timestamp if candles else None

        return candles

    def append_and_get(self, symbol: str, timeframe: int, candle: Candle) -> List[Candle]:
        # Timestamp in UTC-naiv umwandeln, falls nötig:
        if candle.timestamp.tzinfo is not None:
            candle_ts = candle.timestamp.astimezone(pytz.UTC).replace(tzinfo=None)
            candle = Candle(
                timestamp=candle_ts,
                open=candle.open,
                high=candle.high,
                low=candle.low,
                close=candle.close,
                volume=candle.volume
            )

        if timeframe not in self.histories.get(symbol, {}):
            limit = get_history_limit(timeframe)
            self.fetch_history(symbol, timeframe, limit)

        buf = self.histories[symbol][timeframe]
        last_hist_ts = self.last_history_ts.get(symbol, {}).get(timeframe)

        if last_hist_ts and candle.timestamp == last_hist_ts:
            # Bereits vorhanden, nichts ändern
            self.last_history_ts[symbol][timeframe] = None
            return buf

        buf.append(candle)
        self.last_history_ts[symbol][timeframe] = candle.timestamp
        return buf

    def subscribe(self, symbol: str, timeframe: int, callback: Callable):
        # Nur unsere Sekunden-basierten Timeframes (K=900, B=180, E=15) zulassen
        if timeframe not in TIMEFRAMES:
            raise RuntimeError(f"Unsupported timeframe: {timeframe}")

        subs = self.subscribers.setdefault(symbol, {})
        if timeframe not in subs:
            # Historie laden und FSM initialisieren
            history = self.fetch_history(symbol, timeframe, get_history_limit(timeframe))
            self.phase_machine.replay_from_scratch(history)
            subs[timeframe] = []

        if callback not in subs[timeframe]:
            subs[timeframe].append(callback)


    def get_symbol_info(self, contract_id: str) -> SimpleNamespace:
        # Cache Contract-Details
        if contract_id not in self.contract_details_cache:
            contract = self.api.get_contract_details_by_id(contract_id)
            if not contract or "name" not in contract:
                raise RuntimeError(f"Contract-Details oder Name fehlen für {contract_id}")
            self.contract_details_cache[contract_id] = contract
            self.contract_name_cache[contract_id] = contract["name"]
        else:
            contract = self.contract_details_cache[contract_id]

        symbol_name = contract.get("name")
        quote = self.api.get_quote(symbol_name)  # symbolischer Name als Parameter
        if not quote:
            raise RuntimeError(f"API: Quote nicht verfügbar für Symbol {symbol_name}")

        return SimpleNamespace(
            bid=quote.get("bid"),
            ask=quote.get("ask"),
            stop_level=contract.get("tradeStopsLevel", 0),
            tick_size=contract.get("tickSize", 0.0)
        )





        
    def subscribe_candles(self, contract_id: str, timeframe: int, callback: Callable):
        self.subscribe(symbol=contract_id, timeframe=timeframe, callback=callback)


    def run(self):
        self._running = True
        last_processed_second = -1  # verhindert Mehrfachverarbeitung

        while self._running:
            now = datetime.utcnow()

            # Taktprüfung: exakt bei :00/:15/:30/:45 (±300ms Toleranz)
            if now.second % 15 != 0 or now.microsecond > 300_000:
                time.sleep(0.1)
                continue

            # sicherstellen, dass derselbe Zeitpunkt nicht doppelt verarbeitet wird
            if now.second == last_processed_second:
                time.sleep(0.1)
                continue

            last_processed_second = now.second

            for symbol, tfs in list(self.subscribers.items()):
                try:
                    latest_raw = self.api.get_latest_candle(
                        contract_id=symbol,
                        unit=1,
                        unit_number=15
                    )
                except HTTPError as e:
                    print(f"[LIVE DEBUG] HTTPError bei {symbol}: {e.response.status_code} – {e.response.text}")
                    continue

                if not latest_raw:
                    print(f"[LIVE DEBUG] Keine Daten empfangen für {symbol}")
                    continue

                for tf, callbacks in tfs.items():
                    aggregated = aggregate_candles([latest_raw], tf)
                    if not aggregated:
                        continue

                    item = aggregated[0]
                    ts = datetime.utcfromtimestamp(item["timestamp"] / 1000)
                    prev_ts = self.last_history_ts.setdefault(symbol, {}).get(tf)
                    print(f"[DEBUG] Vergleiche Timestamps für {symbol}/{tf}: ts={ts}, prev_ts={prev_ts}")
                    if prev_ts is not None and ts <= prev_ts:
                        continue  # keine neue Kerze

                    print(f"[LIVE DEBUG] Neue Kerze für {symbol}/{tf} @ {ts}")
                    self.last_history_ts[symbol][tf] = ts

                    candle = Candle(
                        timestamp=ts,
                        open=item["open"],
                        high=item["high"],
                        low=item["low"],
                        close=item["close"],
                        volume=item["volume"]
                    )

                    limit = get_history_limit(tf)
                    self.histories.setdefault(symbol, {}).setdefault(tf, []).append(candle)
                    self.histories[symbol][tf] = self.histories[symbol][tf][-limit:]

                    _ = self.phase_machine.update(self.histories[symbol][tf])
                    for cb in callbacks:
                        cb(candle)

            time.sleep(0.1)  # kurze Pause, um CPU zu schonen




