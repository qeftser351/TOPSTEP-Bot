from config.timeframes import K, B, E
from core.tf_manager import MultiTimeframeController
from core.phase_manager import Candle
from projectx_api import ProjectXAPI
from datetime import datetime, timedelta



def max_lots(api: ProjectXAPI, account_id: int, contract_id: str, risk_per_trade: float = 0.01) -> float:
    details = api.get_account_details(account_id)
    # 1) Konto-Details holen
    details = api.get_account_details(account_id)
    if details is None:
        raise RuntimeError("API: Konto-Details nicht abrufbar")
    free_margin = details.get("freeMargin", details.get("balance", 0.0))

    # 2) Aktuellen Preis per Contract-ID holen
    quote = api.get_quote(contract_id=contract_id)
    if not quote:
        raise RuntimeError(f"API: Quote nicht verfügbar für Contract-ID {contract_id}")
    price = quote.get("ask") or quote.get("bid")
    if price is None:
        raise RuntimeError(f"API: Ask/Bid nicht verfügbar für Contract-ID {contract_id}")

    # 3) Contract-Details per Contract-ID abrufen
    contract = api.get_contract_details(contract_id)
    if not contract:
        raise RuntimeError(f"API: Contract-Details nicht verfügbar für Contract-ID {contract_id}")

    margin_per_lot = contract.get("initialMargin") or contract.get("marginInitial")
    if margin_per_lot is None:
        contract_size = contract.get("contractSize", 1.0)
        margin_per_lot = price * contract_size

    # 4) Max. Lots basierend auf Risiko berechnen
    allowed = (free_margin * risk_per_trade) / margin_per_lot

    # 5) Ergebnis runden
    return round(allowed, 2)




class TradingStrategy:
    def __init__(
        self,
        symbol: str,
        data_handler,
        api: ProjectXAPI,
        account_id: int,
        account_balance: float,
        tick_size: float,
        spread: float
    ):
        self.symbol = symbol
        self.api = api
        self.account_id = account_id
        self.data_handler = data_handler
        self.contract_id_map = {}

        self.controller = MultiTimeframeController(
            symbol=symbol,
            api=api,
            account_id=account_id,
            account_balance=account_balance,
            tick_size=tick_size,
            spread=spread,
            data_handler=data_handler,
        )


    def start(self):
        for tf in [K, B, E]:  # z.B. 900s, 180s, 15s
            self.data_handler.subscribe_candles(
                contract_id=self.symbol,
                timeframe=tf,
                callback=lambda c, tf=tf: self.controller.on_new_candle(tf, c)
            )



    def _on_candle(self, timeframe: int, raw_candle) -> None:
        # Angenommen, raw_candle ist jetzt ein Dict:
        # { "timestamp": 1630000000000, "open": ..., "high": ..., "low": ..., "close": ..., "volume": ... }
        c = Candle(
            timestamp=datetime.utcfromtimestamp(raw_candle["timestamp"] / 1000),
            open=raw_candle["open"],
            high=raw_candle["high"],
            low=raw_candle["low"],
            close=raw_candle["close"],
            volume=raw_candle["volume"]
        )
        self.controller.on_new_candle(timeframe, c)
