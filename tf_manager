from projectx_api import ProjectXAPI
import pandas as pd
from typing import Dict, List, Optional
from datetime import datetime
from config.timeframes import K, B, E, get_history_limit, can_k_to_b, can_b_to_e
from core.phase_manager import PhaseStateMachine
from core.candles import Candle, Phase
from core.entry_manager import EntryLogicManager
from core.risk_manager import RiskManager
import logging
import csv
import os
import math
from data_handler import DataHandler
from datetime import datetime, timedelta
from config.timeframes import aggregate_candles
from core.candles import dicts_to_candles
from candle_aggregator import CandleAggregator
from dateutil import parser
from collections import defaultdict
import numpy as np



logger = logging.getLogger(__name__)

# EMA settings
EMA_FAST_PERIOD = 10
EMA_SLOW_PERIOD = 20
EMA_SOURCE      = 'close'
SMOOTH_TYPE     = 'None'
SMOOTH_LENGTH   = 14
SMOOTH_STDDEV   = 2

# --- CSV Logging einbauen ---
def setup_csv(path='summary_log.csv'):
    exists = os.path.isfile(path)
    csvfile = open(path, mode='a', newline='')
    writer = csv.writer(csvfile, delimiter=';')
    if not exists:
        writer.writerow(['timestamp', 'symbol', '15m', '3m', '15s', 'entry', 'sl', 'rr'])
    return csvfile, writer

csvfile, summary_writer = setup_csv()

def log_summary_to_csv(symbol, phase_15m, phase_3m, phase_15s, entry=None, sl=None, rr=None):
    now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    summary_writer.writerow([
        now, symbol, phase_15m, phase_3m, phase_15s,
        entry if entry else "", sl if sl else "", rr if rr else ""
    ])
    csvfile.flush()
# --- Ende CSV Logging ---

def _ema(series: pd.Series, period: int) -> float:
    if len(series) < period:
        return series.iloc[-1]
    sma = series.iloc[-period:].mean()
    k = 2 / (period + 1)
    ema_prev = sma
    for price in series.iloc[-period+1:]:
        ema_prev = price * k + ema_prev * (1 - k)
    return ema_prev

class MultiTimeframeController:
    def __init__(
        self,
        symbol: str,                # z.‚ÄØB. "YMM5"
        api: ProjectXAPI,
        account_id: int,
        account_balance: float,
        tick_size: float,
        spread: float,
        data_handler: DataHandler,
        contract_id: str           # UUID (z.‚ÄØB. "8f83a1b4-...")
    ):
        self.api = api
        self.account_id = account_id
        self.symbol = symbol                   # z.‚ÄØB. "YMM5"
        self.contract_id = contract_id         # z.‚ÄØB. UUID
        self.spread = spread
        self.tick_size = tick_size
        self.data = data_handler
        self.last_agg_ts: Dict[str, Dict[int, int]] = {}

        self.live_quote: Optional[Dict[str, float]] = None

        # API-Zugriff auf Basis der UUID (korrekt)
        self.contract = self.api.get_contract_details_by_id(self.contract_id)
        self.stop_level = self.contract.get("tradeStopsLevel", 0)
        
        self._pending_to_position = defaultdict(dict)


        # Basis-Konfiguration
        self.entry_timestamps: Dict[int, float] = {}

        # Risk-Manager
        self.risk_mgr = RiskManager(
            api=api,
            account_id=account_id,
            account_balance=account_balance,
            symbol=symbol,
            spread=spread,
            tick_size=tick_size
        )
        
        #Breakeven schon gesetzt
        self.break_even_applied: Dict[int, bool] = {}

        # Phase-State Machines und Entry Logic
        self.machines = {tf: PhaseStateMachine() for tf in (K, B, E)}
        self.entry_mgr = EntryLogicManager(self.machines[E], spread)

        # Zustand
        self.phases: Dict[int, Phase] = {}
        self.history: Dict[int, List[Candle]] = {}
        self.open_ticket: Optional[int] = None
        self.entry_price: Optional[float] = None
        self.initial_stop: Optional[float] = None
        self.current_sl: Optional[float] = None
        self.side: Optional[str] = None
        self.active_tf = K

        # Speicherung f√ºr Switch-Extrema
        self.switch_data: Dict[int, Dict[str, float]] = {K: {}, B: {}, E: {}}
        self.entered_direction: Optional[str] = None
        
        self.last_update_ts: Dict[int, Optional[datetime]] = {K: None, B: None, E: None}

    def initialize(self) -> None:
        # Debug-Start
        print("[INIT] initialize() wurde gestartet")

        # Cleanup alter Pending-Orders API-RDY
        for o in self.api.get_open_orders(self.account_id):
            if o.get("customTag") == "234000":
                self.api.cancel_order(o["orderId"])


        # Cleanup alter Positionen API-RDY
        for pos in self.api.get_positions(self.account_id):
            if pos.get("customTag") == "234000":
                side = "sell" if pos["side"].lower()=="buy" else "buy"
                # Verwende Order-Typ MARKET: limitPrice/stopPrice weglassen
                self.api.place_order(
                    account_id=self.account_id,
                    contract_id=pos["contractId"],
                    order_type="MARKET",
                    side=side,
                    size=pos["size"],
                    custom_tag="234000"
                )


        # Reset interne State
        self.open_ticket = None
        self.entry_price = None
        self.initial_stop = None
        self.current_sl = None
        self.side = None

        # Lade History & Phasen
        MIN_CANDLES = 10
        for tf in (E, B, K):
            raw = self.data.fetch_history(self.contract_id, tf, get_history_limit(tf))
            hist = raw[:-1]
            fsm = self.machines[tf]
            fsm.reset()
            fsm.context['last_candles'] = hist
            phase = fsm.replay_from_scratch(hist)
            self.history[tf] = hist
            self.phases[tf] = phase
            
            ctx = fsm.context
            if phase in (Phase.BASE_SWITCH_BULL, Phase.SWITCH_BULL):
                self.switch_data[tf] = {
                    'initial_extreme':  ctx.get('switch_bull_initial_low'),
                    'previous_extreme': ctx.get('switch_bull_prev_higher_high')
                }
            elif phase in (Phase.BASE_SWITCH_BEAR, Phase.SWITCH_BEAR):
                self.switch_data[tf] = {
                    'initial_extreme':  ctx.get('switch_bear_initial_high'),
                    'previous_extreme': ctx.get('switch_bear_prev_lower_low')
                }

        # √úbernehme offene Pending-Orders API-RDY
        for order in self.api.get_open_orders(self.account_id):
            if order.get("customTag") == "234000":
                self.open_ticket = order["orderId"]
                self.entry_price = order["price"]
                self.initial_stop = order["stopPrice"]
                self.current_sl = order["stopPrice"]
                self.side = "buy" if order["side"].lower()=="buy" else "sell"
                entry_ts = order["timestamp"]  # ms
                self.entry_timestamps[self.open_ticket] = entry_ts

        # √úbernehme bestehende Positionen API-RDY
        for pos in self.api.get_positions(self.account_id):
            if pos.get("customTag") == "234000":
                self.open_ticket = pos["positionId"]
                self.entry_price = pos["entryPrice"]
                self.initial_stop = pos["initialStop"]
                self.current_sl = pos["initialStop"]
                self.side = "buy" if pos["side"].lower()=="buy" else "sell"
                entry_ts = pos["timestampOpen"]  # ms
                self.entry_timestamps[self.open_ticket] = entry_ts
                self.break_even_applied[self.open_ticket] = False
                self.risk_mgr.trailing_levels[self.open_ticket] = 0


        # Initialer Phasenwechsel
        if can_k_to_b(self.phases[K]):
            self.entered_direction = 'buy' if 'BULL' in self.phases[K].name else 'sell'
            self._record_switch(K, self.history[K], 'low' if self.entered_direction=='buy' else 'high')
            self._switch_to(B)
            if can_b_to_e(self.phases[K], self.phases[B]):
                self.entered_direction = 'buy' if 'BULL' in self.phases[B].name else 'sell'
                self._record_switch(B, self.history[B], 'low' if self.entered_direction=='buy' else 'high')
                self._switch_to(E)
        elif can_b_to_e(self.phases[K], self.phases[B]):
            self.entered_direction = 'buy' if 'BULL' in self.phases[B].name else 'sell'
            self._record_switch(B, self.history[B], 'low' if self.entered_direction=='buy' else 'high')
            self._switch_to(E)

        self._sync_ticket_state_with_api()
        
        print("[INIT] initialize() abgeschlossen ‚Äì erste Zusammenfassung:")
        self.print_summary()
    
    #API-RDY
    def fetch_history(self, symbol: str, tf_seconds: int, limit: int) -> list[Candle]:
        end_time = datetime.utcnow()
        start_time = end_time - timedelta(seconds=tf_seconds * limit)

        if tf_seconds % 3600 == 0:
            unit = 3
            unit_number = tf_seconds // 3600
        elif tf_seconds % 60 == 0:
            unit = 2
            unit_number = tf_seconds // 60
        else:
            unit = 1
            unit_number = tf_seconds

        raw = self.api.get_candles(
            contract_id=symbol,
            unit=unit,
            unit_number=unit_number,
            limit=limit,
            live=False,
            start_time=start_time,
            end_time=end_time,
            include_partial_bar=False
        )

        if not raw:
            print(f"[ERROR] Keine historischen Kerzen empfangen f√ºr {symbol} @ {tf_seconds}s")
            return []

        df = pd.DataFrame(raw)
        df.rename(columns={"t": "timestamp", "o": "open", "h": "high", "l": "low", "c": "close", "v": "volume"}, inplace=True)

        def parse_ts(ts):
            if isinstance(ts, (int, float, np.integer)):
                return pd.to_datetime(int(ts), unit='ms', utc=True).tz_convert(None)
            elif isinstance(ts, str):
                return pd.to_datetime(ts, utc=True).tz_convert(None)
            elif isinstance(ts, (datetime, pd.Timestamp)):
                return pd.to_datetime(ts, utc=True).tz_convert(None)
            else:
                raise TypeError(f"[fetch_history] Unsupported timestamp type: {type(ts)} ‚Üí {ts}")

        df["timestamp"] = df["timestamp"].apply(parse_ts)

        records = df.to_dict(orient="records")
        if unit * unit_number != tf_seconds:
            from config.timeframes import aggregate_candles
            records = aggregate_candles(records, tf_seconds)

        return [Candle(
            timestamp=c["timestamp"],
            open=c["open"], high=c["high"],
            low=c["low"], close=c["close"],
            volume=c["volume"],
            open_bid=c.get("open_bid"),
            high_bid=c.get("high_bid"),
            low_bid=c.get("low_bid"),
            close_bid=c.get("close_bid"),
            open_ask=c.get("open_ask"),
            high_ask=c.get("high_ask"),
            low_ask=c.get("low_ask"),
            close_ask=c.get("close_ask"),
        ) for c in records]





    #API-RDY
    def get_active_position_ticket(self) -> Optional[int]:
        pos_list = [
            p for p in self.api.get_positions(self.account_id)
            if p.get("customTag") == "234000"
        ]
        if pos_list:
            return pos_list[0]["positionId"]
        return None


    def on_new_candle(self, contract_id: str, tf: int, candle):
        assert isinstance(candle, Candle), f"Ung√ºltiger Candle-Typ: {type(candle)} ‚Üí {candle}"

        print(f"[TFManager] Trigger: symbol={self.symbol} timeframe={tf} @ {candle.timestamp} OHLC={candle.open}/{candle.high}/{candle.low}/{candle.close}")
    
        if tf == E:
            quote = self.api.get_current_price(self.symbol)
            bid = quote.get("bid")
            ask = quote.get("ask")

            if bid is None or ask is None:
                print(f"[WARN] No bid/ask for {self.symbol}")
            else:
                print(f"[{tf}] Entry-Candle: {candle.timestamp} | bid={bid} ask={ask}")




        
        # 1) Sync Entry-Timestamps sofort ganz oben API-RDY
        if tf == E:
            positions = [ pos for pos in self.api.get_positions(self.account_id) if pos.get("customTag")=="234000" ]
            print(f"[SYNC] Aktive Positionen vor FSM: {len(positions)}")
            for p in positions:
                if p["positionId"] not in self.entry_timestamps:
                    entry_ts = p["timestampOpen"]       # ms
                    self.entry_timestamps[p["positionId"]] = entry_ts
                    self.open_ticket   = p["positionId"]
                    self.entry_price   = p["entryPrice"]
                    self.initial_stop  = p["initialStop"]
                    self.current_sl    = p["initialStop"]
                    self.side          = 'buy' if p["side"].lower()=="buy" else 'sell'
                    self.break_even_applied[p["positionId"]]   = False
                    self.risk_mgr.trailing_levels[p["positionId"]] = 0
                    
            # üîÅ NEU: Trigger Aggregation h√∂herer Timeframes ausgehend von E
            self.try_aggregate_higher_timeframes(contract_id, candle.timestamp)
        
        # Neue Candle? Update FSM, aber ohne fetch_history
        for tf_upd in (K, B):
            if tf_upd == tf:
                continue  # aktuelle TF √ºberspringen

            history = self.data.histories.get(contract_id, {}).get(tf_upd, [])
            if not history:
                continue

            latest = history[-1]
            last_ts = self.last_update_ts.get(tf_upd)

            # Nur wenn neue Kerze eingetroffen ist
            if last_ts is None or latest.timestamp > last_ts:
                self.machines[tf_upd].context["last_candles"] = history
                new_phase = self.machines[tf_upd].update(history)
                self.phases[tf_upd] = new_phase
                self.machines[tf_upd].context["prev_phase"] = new_phase
                self.last_update_ts[tf_upd] = latest.timestamp

                # Optional: Switch-Daten aktualisieren
                ctx = self.machines[tf_upd].context
                if new_phase == Phase.BASE_SWITCH_BULL:
                    self.switch_data[tf_upd] = {
                        "initial_extreme": ctx.get("switch_bull_initial_low"),
                        "previous_extreme": ctx.get("switch_bull_prev_higher_high"),
                    }
                elif new_phase == Phase.BASE_SWITCH_BEAR:
                    self.switch_data[tf_upd] = {
                        "initial_extreme": ctx.get("switch_bear_initial_high"),
                        "previous_extreme": ctx.get("switch_bear_prev_lower_low"),
                    }
                elif new_phase == Phase.SWITCH_BULL:
                    self.switch_data[tf_upd] = {
                        "initial_extreme": ctx.get("switch_bull_initial_low"),
                        "previous_extreme": ctx.get("switch_bull_prev_higher_high"),
                    }
                elif new_phase == Phase.SWITCH_BEAR:
                    self.switch_data[tf_upd] = {
                        "initial_extreme": ctx.get("switch_bear_initial_high"),
                        "previous_extreme": ctx.get("switch_bear_prev_lower_low"),
                    }

                
                # Direkt nach jedem neuen K-Update pr√ºfen:
                if tf_upd == K and self.active_tf == K and can_k_to_b(self.phases[K]):
                    self.entered_direction = 'buy' if 'BULL' in self.phases[K].name else 'sell'
                    extreme = 'low' if self.entered_direction == 'buy' else 'high'
                    self._record_switch(K, self.history[K], extreme)
                    self._switch_to(B)
                    # Optional: Wenn b‚Üíe auch sofort m√∂glich, direkt weiter nach E:
                    if can_b_to_e(self.phases[K], self.phases[B]):
                        self.entered_direction = 'buy' if 'BULL' in self.phases[B].name else 'sell'
                        extreme = 'low' if self.entered_direction == 'buy' else 'high'
                        self._record_switch(B, self.history[B], extreme)
                        self._switch_to(E)
                    return
                
                # --- 2. Nach B-Update: sofort nach E ---
                if tf_upd == B and self.active_tf == B and can_b_to_e(self.phases[K], self.phases[B]):
                    self.entered_direction = 'buy' if 'BULL' in self.phases[B].name else 'sell'
                    extreme = 'low' if self.entered_direction == 'buy' else 'high'
                    self._record_switch(B, self.history[B], extreme)
                    self._switch_to(E)
                    return
                
                
            # Direkt nach jedem neuen K- oder B-Update pr√ºfen:
            if self.active_tf == B and can_b_to_e(self.phases[K], self.phases[B]):
                self.entered_direction = 'buy' if 'BULL' in self.phases[B].name else 'sell'
                extreme = 'low' if self.entered_direction == 'buy' else 'high'
                self._record_switch(B, self.history[B], extreme)
                self._switch_to(E)
                return
        
        # Doppeltes Update pro Kerze verhindern!
        if self.last_update_ts[tf] == candle.timestamp:
            print(f"[WARN] Doppeltes Update f√ºr TF={tf} Candle={candle.timestamp}!")
            return
        self.last_update_ts[tf] = candle.timestamp
        # Nur aktiver TF
        if tf != self.active_tf:
            return

        # 1) History updaten
        self.history[tf].append(candle)
        buf = self.history[tf]

        # 2) Context vorbereiten
        self.machines[tf].context['last_candles'] = buf  # <--- NEU!

        # Die update()-Methode bekommt jetzt die gesamte Kerzenliste!
        new_phase = self.machines[tf].update(buf)

        # --- NEU: Pending-Order-Check f√ºr TREND-BULL/-BEAR ---
        if tf == E and new_phase in (Phase.TREND_BULL, Phase.TREND_BEAR):
            pending_orders = [ o for o in self.api.get_open_orders(self.account_id) if o.get("customTag")=="234000" ]
            if pending_orders:
                # Solange Pending-Order existiert, bleibe auf BASE_SWITCH!
                if self.entered_direction == "buy":
                    new_phase = Phase.BASE_SWITCH_BULL
                elif self.entered_direction == "sell":
                    new_phase = Phase.BASE_SWITCH_BEAR

        self.phases[tf] = new_phase
        # ‚îÄ‚îÄ neu: die gerade ermittelte Phase als prev_phase merken ‚îÄ‚îÄ
        self.machines[tf].context['prev_phase'] = new_phase

        # ‚îÄ‚îÄ‚îÄ Block A: Wenn wir in B sind, aber K und B nicht mehr synchron sind oder K seine Ursprungsrichtung ge√§ndert hat ‚îÄ‚îÄ‚îÄ
        if tf == B and self.entered_direction is not None:
            # aktuelle K-Richtung ermitteln
            k_phase = self.phases[K]
            current_k_dir = 'buy' if 'BULL' in k_phase.name else 'sell'
            b_phase = self.phases[B]
            current_b_dir = 'buy' if 'BULL' in b_phase.name else 'sell'
            # ZUERST: Richtungsgleichheit B/K pr√ºfen!
            if current_b_dir != current_k_dir:
                self.entered_direction = None
                self._switch_to(K)
                return

            # Dann wie gehabt: Vergleich mit der initialen Richtung aus K
            if current_k_dir != self.entered_direction:
                self.entered_direction = None
                self._switch_to(K)
                return

        
        BASE_PHASES = (
            Phase.BASE_BULL, Phase.BASE_BEAR, 
            Phase.BASE_SWITCH_BULL, Phase.BASE_SWITCH_BEAR
        )
        
        
        # ‚îÄ‚îÄ‚îÄ Block B: Wenn wir in E sind, aber B und K nicht mehr synchron sind ODER B seine Ursprungsrichtung ge√§ndert hat ‚îÄ‚îÄ‚îÄ
        if tf == E and self.entered_direction is not None:
            b_phase = self.phases[B]
            k_phase = self.phases[K]
            current_b_dir = 'buy' if 'BULL' in b_phase.name else 'sell'
            current_k_dir = 'buy' if 'BULL' in k_phase.name else 'sell'

            if self._has_active_trade():
                pass
                # KEIN return! Einfach nichts machen, d.h. der R√ºckwechsel-Block wird √ºbersprungen!
            else:
                # R√ºckwechsel zu B oder K pr√ºfen, falls kein Trade offen:
                if b_phase not in BASE_PHASES:
                    self.entered_direction = None
                    self._switch_to(B)
                    self.phases[E] = Phase.NEUTRAL
                    return

                if current_b_dir != current_k_dir:
                    self.entered_direction = None
                    self._switch_to(K)
                    return

                if current_b_dir != self.entered_direction:
                    self.entered_direction = None
                    self._switch_to(B)
                    return


        
        
        # Break-Even und Trailing im E-Timeframe
        if tf == E:
            # Sicherstellen, dass Positionen aus Sync verf√ºgbar sind API-RDY
            positions = [ pos for pos in self.api.get_positions(self.account_id) if pos.get("customTag")=="234000" ]
            for p in positions:
                ticket   = p["positionId"]
                entry_ts = self.entry_timestamps.get(p["positionId"])
                if entry_ts is None:
                    print(f"[WARN] Kein Entry-Timestamp f√ºr Ticket {ticket}")
                    continue
                buf_e = [c for c in self.history[E] if c.timestamp >= entry_ts]
                print(f"[DEBUG] buf_e length f√ºr Ticket {ticket}: {len(buf_e)}")

                # Break-Even
                new_sl = self.risk_mgr.try_break_even(
                    candles=buf_e,
                    side=self.side,
                    entry_price=self.entry_price,
                    spread=self.spread,
                    current_sl=self.current_sl,
                    symbol=self.symbol,
                    ticket=ticket
                )
                if new_sl is not None:
                    self.current_sl = new_sl
                    self.break_even_applied[ticket] = True
                    print(f"[BE] Break-Even aktiviert: new_sl={new_sl} for Ticket={ticket}")

                # Trailing
                new_sl = self.risk_mgr.try_trailing(
                    candles=buf_e,
                    symbol=self.symbol,
                    side=self.side,
                    entry_price=self.entry_price,
                    initial_stop=self.initial_stop,
                    current_sl=self.current_sl,
                    ticket=ticket
                )
                if new_sl is not None:
                    self.current_sl = new_sl
                    print(f"[TR] Trailing Stop applied: new_sl={new_sl} for Ticket={ticket}")


        # 4) Switch-Daten aus Context abholen
        ctx = self.machines[tf].context
        if new_phase == Phase.BASE_SWITCH_BULL:
            self.switch_data[tf] = {
                'initial_extreme':     ctx.get('switch_bull_initial_low'),
                'previous_extreme':    ctx.get('switch_bull_prev_higher_high')
            }
        elif new_phase == Phase.BASE_SWITCH_BEAR:
            self.switch_data[tf] = {
                'initial_extreme':     ctx.get('switch_bear_initial_high'),
                'previous_extreme':    ctx.get('switch_bear_prev_lower_low')
            }
        # ‚îÄ‚îÄ‚îÄ> Hier erg√§nzen:
        elif new_phase == Phase.SWITCH_BULL:
            self.switch_data[tf] = {
                'initial_extreme':     ctx.get('switch_bull_initial_low'),
                'previous_extreme':    ctx.get('switch_bull_prev_higher_high')
            }
        elif new_phase == Phase.SWITCH_BEAR:
            self.switch_data[tf] = {
                'initial_extreme':     ctx.get('switch_bear_initial_high'),
                'previous_extreme':    ctx.get('switch_bear_prev_lower_low')
            }

        # 5) K‚ÜíB Wechsel
        if tf == K and new_phase in (
            Phase.BASE_SWITCH_BULL, Phase.BASE_BULL,
            Phase.BASE_SWITCH_BEAR, Phase.BASE_BEAR,
            Phase.TREND_BULL, Phase.TREND_BEAR
        ):
            self.entered_direction = 'buy' if 'BULL' in new_phase.name else 'sell'
            extreme = 'low' if self.entered_direction == 'buy' else 'high'
            self._record_switch(K, buf, extreme)
            self._switch_to(B)
            # NEU: Pr√ºfe SOFORT, ob b‚Üíe schon jetzt m√∂glich ist!
            if can_b_to_e(self.phases[K], self.phases[B]):
                self.entered_direction = 'buy' if 'BULL' in self.phases[B].name else 'sell'
                extreme = 'low' if self.entered_direction == 'buy' else 'high'
                self._record_switch(B, self.history[B], extreme)
                self._switch_to(E)
            return

        # 6) B‚ÜíE Wechsel
        if tf == B and can_b_to_e(self.phases[K], new_phase):
            self.entered_direction = 'buy' if 'BULL' in new_phase.name else 'sell'
            extreme = 'low' if self.entered_direction == 'buy' else 'high'
            self._record_switch(B, buf, extreme)
            self._switch_to(E)
            return

        # 7) E-Timeframe: Entry nach BASE_SWITCH
        if tf == E and new_phase in (Phase.BASE_SWITCH_BULL, Phase.BASE_SWITCH_BEAR):
            # Confirmation durch FSM sichergestellt
            extreme = 'low' if new_phase == Phase.BASE_SWITCH_BULL else 'high'
            self._record_switch(E, buf, extreme)
            logger.info(f"Confirmation Candle detected: {candle}, close={candle.close}")

            # Contract-ID aus Cache holen oder laden
            if not hasattr(self, "contract_id_map"):
                self.contract_id_map = {}

            if self.symbol not in self.contract_id_map:
                # Pr√ºfen, ob self.symbol bereits eine Contract-ID ist (beginnt mit "CON.")
                if self.symbol.startswith("CON."):
                    self.contract_id_map[self.symbol] = self.symbol
                else:
                    contract = self.api.get_contract_by_name(self.symbol)
                    self.contract_id_map[self.symbol] = contract["id"]

            contract_id = self.contract_id_map[self.symbol]

            # Quote per Contract-ID holen
            quote = self.api.get_current_price(contract_id)
            ask = quote.get("ask")
            bid = quote.get("bid")



            entry = None
            if self.entered_direction == 'buy' and new_phase == Phase.BASE_SWITCH_BULL:
                entry = self.entry_mgr.check_buy_stop(buf, ask, stop_level, tick_size)
            elif self.entered_direction == 'sell' and new_phase == Phase.BASE_SWITCH_BEAR:
                entry = self.entry_mgr.check_sell_stop(buf, bid, stop_level, tick_size)
            #API-RDY
            if entry:
                open_pos = self.api.get_positions(self.account_id) or []
                open_ord = self.api.get_open_orders(self.account_id) or []
                active = any(p.get("customTag")=="234000" for p in open_pos) or \
                    any(o.get("customTag")=="234000" for o in open_ord)
                if not active:
                    self._open_new_trade(entry)
        
        # --- NEU: Extra-Schutz ‚Äì Buy/Sell-Stop nur in passender Phase ---
        if tf == E:
            long_phases = (
                Phase.BASE_BULL, Phase.TREND_BULL, Phase.SWITCH_BULL, Phase.BASE_SWITCH_BULL
            )
            short_phases = (
                Phase.BASE_BEAR, Phase.TREND_BEAR, Phase.SWITCH_BEAR, Phase.BASE_SWITCH_BEAR
            )
            for order in self.api.get_open_orders(self.account_id) or []:
                if order.get("customTag") != "234000":
                    continue
                # L√∂sche Buy-Stop, falls aktuelle Phase KEINE Long-Phase mehr ist
                if order.get("type") == "BUY_STOP" and new_phase not in long_phases:
                    print(f"[ORDER-MANAGER] Buy Stop gel√∂scht wegen Phasewechsel: {new_phase.name}")
                    self.api.cancel_order(order["orderId"])
                    if self.open_ticket == order["orderId"]:
                        self.open_ticket = None
                # L√∂sche Sell-Stop, falls aktuelle Phase KEINE Short-Phase mehr ist
                if order.get("type") == "SELL_STOP" and new_phase not in short_phases:
                    print(f"[ORDER-MANAGER] Sell Stop gel√∂scht wegen Phasewechsel: {new_phase.name}")
                    self.api.cancel_order(order["orderId"])
                    if self.open_ticket == order["orderId"]:
                        self.open_ticket = None


        # 8) Gegens√§tzliche Pending-Orders bei Phasenwechsel canceln
        if tf == E and new_phase in (Phase.SWITCH_BULL, Phase.BASE_SWITCH_BULL, Phase.SWITCH_BEAR, Phase.BASE_SWITCH_BEAR):
            for order in self.api.get_open_orders(self.account_id) or []:
                if order.get("customTag") != "234000":
                    continue
                # cancel Sell-Stop on Bull switch
                if new_phase in (Phase.SWITCH_BULL, Phase.BASE_SWITCH_BULL) and order.get("type") == "SELL_STOP":
                    self.api.cancel_order(order["orderId"])
                    if self.open_ticket == order["orderId"]:
                        self.open_ticket = None
                # cancel Buy-Stop on Bear switch
                if new_phase in (Phase.SWITCH_BEAR, Phase.BASE_SWITCH_BEAR) and order.get("type") == "BUY_STOP":
                    self.api.cancel_order(order["orderId"])
                    if self.open_ticket == order["orderId"]:
                        self.open_ticket = None



        # 10) Cleanup nach Trade-Close f√ºr ALLE nicht mehr aktive Tickets
        aktive_tickets = set(pos["positionId"] for pos in self.api.get_positions(self.account_id))

        # _pending_to_position cleanup
        if symbol in self.data._pending_to_position:
            for ticket in list(self.data._pending_to_position[symbol].keys()):
                if ticket not in aktive_tickets:
                    self.data._pending_to_position[symbol].pop(ticket, None)
            if not self.data._pending_to_position[symbol]:
                self.data._pending_to_position.pop(symbol)

        # weitere per-Ticket Cleanups
        for ticket in list(self.entry_timestamps.keys()):
            if ticket not in aktive_tickets:
                self.entry_timestamps.pop(ticket, None)
                self.break_even_applied.pop(ticket, None)
                self.risk_mgr.trailing_levels.pop(ticket, None)




            
        self._sync_ticket_state_with_api()
        
        
        # 9) Guard gegen neue Entries
        pend = self.api.get_open_orders(self.account_id) or []
        pos  = self.api.get_positions(self.account_id) or []
        if pend or any(p.get("customTag") == "234000" for p in pos):
            return

        # contract_id laden/cache
        if not hasattr(self, "contract_id_map"):
            self.contract_id_map = {}
        if self.symbol not in self.contract_id_map:
            contract = self.api.get_contract_by_name(self.symbol)
            self.contract_id_map[self.symbol] = contract["id"]
        contract_id = self.contract_id_map[self.symbol]

        contract = self.api.get_contract_details_by_id(contract_id)
        stop_level = contract.get("tradeStopsLevel", 0)
        tick_size = contract.get("tickSize", self.tick_size)  # fallback

        quote = self.api.get_current_price(contract_id)
        ask = quote.get("ask")
        bid = quote.get("bid")


        
                # 11) Entry-Logik (Fallback)
        base  = self.phases[B]
        elite = self.phases[E]
        entry = None
        if base in (Phase.BASE_BULL, Phase.BASE_SWITCH_BULL) and elite==Phase.BASE_SWITCH_BULL:
            entry = self.entry_mgr.check_buy_stop(buf, ask, stop_level, tick_size)
        if base in (Phase.BASE_BEAR, Phase.BASE_SWITCH_BEAR) and elite==Phase.BASE_SWITCH_BEAR:
            entry = self.entry_mgr.check_sell_stop(buf, bid, stop_level, tick_size)
        if entry:
            self._open_new_trade(entry)
            
    def try_aggregate_higher_timeframes(self, contract_id: str, last_15s_ts: datetime):
        buffer = self.data.histories.get(contract_id, {}).get(15, [])
        if len(buffer) < 12:
            return

        candles_raw = [c.to_dict() for c in buffer]

        for target_tf in [180, 900]:  # 3m, 15m
            aligned_ts = int(last_15s_ts.timestamp()) - (int(last_15s_ts.timestamp()) % target_tf)

            if self.last_agg_ts.get(contract_id, {}).get(target_tf) == aligned_ts:
                continue  # Schon aggregiert

            aggregated = aggregate_candles(candles_raw, target_tf)
            candles = dicts_to_candles(aggregated)

            for c in candles:
                if int(c.timestamp.timestamp()) == aligned_ts:
                    self.last_agg_ts.setdefault(contract_id, {})[target_tf] = aligned_ts
                    self.on_new_candle(contract_id, target_tf, c)




            
    def _sync_ticket_state_with_api(self):
        """Synchronisiere Ticket-State nach FSM-Reset oder Replay."""
        aktuelle_tickets = set()
        # Sammle alle offenen Positionen des Bots API-RDY
        for pos in self.api.get_positions(self.account_id):
            if pos.get("customTag") == "234000":
                aktuelle_tickets.add(pos["positionId"])
                if pos["positionId"] not in self.break_even_applied:
                    self.break_even_applied[pos["positionId"]] = False
                if pos["positionId"] not in self.risk_mgr.trailing_levels:
                    self.risk_mgr.trailing_levels[pos["positionId"]] = 0
        # L√∂sche ALLE State-Flags f√ºr Tickets, die nicht mehr offen sind!
        for t in list(self.break_even_applied.keys()):
            if t not in aktuelle_tickets:
                self.break_even_applied.pop(t, None)
        for t in list(self.risk_mgr.trailing_levels.keys()):
            if t not in aktuelle_tickets:
                self.risk_mgr.trailing_levels.pop(t, None)
        # Gleiches ggf. f√ºr entry_timestamps, falls du das so willst
        for t in list(self.entry_timestamps.keys()):
            if t not in aktuelle_tickets:
                self.entry_timestamps.pop(t, None)

    def _open_new_trade(self, entry: Dict[str, float]) -> None:
        tick = self.tick_size
        
        contract_id = self.contract_id_map.get(self.symbol)
        contract = self.api.get_contract_details_by_id(contract_id)
        stop_level = contract.get("tradeStopsLevel", 0)

        # Runden auf Tickgr√∂√üe
        entry_price = math.floor(entry['entry_price'] / tick) * tick
        stop_loss   = math.floor(entry['stop_loss']   / tick) * tick

        self.side = entry['side']
        self.entry_price = entry_price
        entry_ts = self.history[E][-1].timestamp
        self.initial_stop = stop_loss

        # Positionsgr√∂√üe berechnen mit gerundeten Werten
        size = self.risk_mgr.calculate_position_size(
            self.symbol, entry_price, stop_loss, self.side
        )

        # Debug
        print(f"[DEBUG] _open_new_trade: side={self.side}, entry_price={entry_price}, stop_loss={stop_loss}, size={size}, tick={tick}")

        res = self.api.place_order(
            account_id=self.account_id,
            contract_id=self.symbol,
            order_type="STOP",      # oder ‚ÄúLIMIT‚Äù, je nachdem, was EntryLogicManager liefert
            side=self.side,
            size=size,
            stop_price=stop_loss,
            custom_tag="234000"
        )
        if res and res.get("orderId"):
            self.open_ticket = res["orderId"]
            self.current_sl = stop_loss
            self.entry_timestamps[self.open_ticket] = entry_ts
            rr_pips = abs(entry_price - stop_loss) / self.tick_size
            print(f"[INFO] Trade er√∂ffnet (Ticket={self.open_ticket}): 1RR = {rr_pips:.1f} Pips")
            # SL nachtr√§glich anpassen, falls n√∂tig:
            self.api.update_position_stop(self.open_ticket, stop_loss=stop_loss)




    def _switch_to(self, tf: int) -> None:
        raw_hist = self.fetch_history(self.contract_id, tf, get_history_limit(tf))
        hist = raw_hist[:-1]
        if not hist or len(hist) < 3:
            return
        self.machines[tf].context.clear()
        self.history[tf]=hist
        self.machines[tf].context['last_candles'] = hist
        self.phases[tf] = self.machines[tf].replay_from_scratch(hist)
        self.active_tf=tf
        if tf == K:
            self._bounce_from_k_if_needed()

        
        
    def _bounce_from_k_if_needed(self):
        """Nach R√ºcksprung auf K pr√ºfen, ob wir SOFORT wieder nach B gehen sollen."""
        k_phase = self.phases[K]
        if k_phase in (
            Phase.BASE_SWITCH_BULL, Phase.BASE_BULL,
            Phase.BASE_SWITCH_BEAR, Phase.BASE_BEAR,
            Phase.TREND_BULL, Phase.TREND_BEAR
        ):
            self.entered_direction = 'buy' if 'BULL' in k_phase.name else 'sell'
            extreme = 'low' if self.entered_direction == 'buy' else 'high'
            self._record_switch(K, self.history[K], extreme)
            self._switch_to(B)


    def _record_switch(self, tf: int, buf: List[Candle], extreme: str) -> None:
        ctx = self.machines[tf].context
        if extreme == 'low':
            initial = ctx.get('switch_bull_initial_low')
            prev = ctx.get('switch_bull_prev_higher_high')
        else:
            initial = ctx.get('switch_bear_initial_high')
            prev = ctx.get('switch_bear_prev_lower_low')
        self.switch_data[tf] = {'initial_extreme': initial, 'previous_extreme': prev}

        
    def _has_active_trade(self) -> bool:
        open_pos = [ p for p in self.api.get_positions(self.account_id) if p.get("customTag")=="234000" ]
        open_ord = [ o for o in self.api.get_open_orders(self.account_id) if o.get("customTag")=="234000" ]
        return bool(open_pos or open_ord)

    
    



    def print_summary(self) -> None:
        now_dt = None
        if self.history.get(self.active_tf):
            last = self.history[self.active_tf][-1]
            ts = last.timestamp
            if isinstance(ts, (int, float, np.integer)):
                ts = pd.to_datetime(int(ts), unit='ms' if ts > 1e12 else 's', utc=True)
            else:
                ts = pd.to_datetime(ts, utc=True)
            now_dt = ts.tz_convert("Europe/Berlin")
        now_str = now_dt.strftime("%Y-%m-%d %H:%M:%S") if now_dt else datetime.now().strftime("%Y-%m-%d %H:%M:%S")

        print(f"[{now_str}] {self.symbol} summary:")
        entry, sl, rr = None, None, None

        for tf in (K, B, E):
            lbl = {K: '15m', B: '3m', E: '15s'}[tf]
            phase = self.phases.get(tf)
            act = '*' if tf == self.active_tf else ''
            line = f"  {lbl}{act}: {phase.name if phase else 'N/A'}"

            history = self.history.get(tf)
            if history and len(history) >= 20:
                close_prices = pd.Series([getattr(c, EMA_SOURCE) for c in history])
                ema_10 = _ema(close_prices, 10)
                ema_20 = _ema(close_prices, 20)
                last_candle = history[-1]
                ts = last_candle.timestamp

                # ‚úÖ Zeit robust parsen + Berliner Zeit
                if isinstance(ts, (int, float, np.integer)):
                    ts = pd.to_datetime(int(ts), unit='ms' if ts > 1e12 else 's', utc=True)
                else:
                    ts = pd.to_datetime(ts, utc=True)
                ts = ts.tz_convert("Europe/Berlin")

                line += f" | last_candle: {ts.strftime('%Y-%m-%d %H:%M:%S')} | EMA10={ema_10:.5f} EMA20={ema_20:.5f}"
            else:
                line += " | EMA10/20: n/a"

            if phase == Phase.SWITCH_BULL:
                d = self.switch_data.get(tf, {})
                line += f" | initLow={d.get('initial_extreme')} prevHigh={d.get('previous_extreme')}"
            if phase == Phase.SWITCH_BEAR:
                d = self.switch_data.get(tf, {})
                line += f" | initHigh={d.get('initial_extreme')} prevLow={d.get('previous_extreme')}"

            if tf == E and self.open_ticket is not None:
                has_order = any(
                    o["orderId"] == self.open_ticket
                    for o in self.api.get_open_orders(self.account_id)
                    if o.get("customTag") == "234000"
                )
                has_pos = any(
                    p["positionId"] == self.open_ticket
                    for p in self.api.get_positions(self.account_id)
                    if p.get("customTag") == "234000"
                )
                if has_order or has_pos:
                    rr = (abs(self.entry_price - self.initial_stop)
                        if self.entry_price and self.initial_stop else None)
                    line += f" | entry={self.entry_price:.5f}, sl={self.initial_stop:.5f}"
                    if rr is not None:
                        line += f", 1RR={rr:.5f}"
                else:
                    self.open_ticket = None
                    self.entry_price = None
                    self.initial_stop = None
                    self.current_sl = None
                    self.side = None

            print(line)

            
        # --- Hier der Aufruf f√ºrs CSV-Logging ---
        phase_15m = self.phases.get(K).name if self.phases.get(K) else ""
        phase_3m = self.phases.get(B).name if self.phases.get(B) else ""
        phase_15s = self.phases.get(E).name if self.phases.get(E) else ""
        log_summary_to_csv(self.symbol, phase_15m, phase_3m, phase_15s, entry, sl, rr)


    def stop(self) -> None:
        self.api.logout()


if __name__ == "__main__":
    # Initialisierung, Instanzen, Subscription, etc.
    api = ProjectXAPI(...)
    account_id = 123456
    symbol = "CON.1234"
    contract_id = symbol
    timeframe = 15
    balance = 10000.0
    tick_size = 0.01
    spread = 0.02
    token = "YOUR_WS_API_TOKEN"

    handler = DataHandler(api, account_id)
    strategy = MultiTimeframeController(symbol, api, account_id, balance, tick_size, spread, handler)

    handler.subscribe_candles(contract_id, timeframe, lambda candle: strategy.on_new_candle(timeframe, candle))
    handler.start_ws(token, [contract_id])
